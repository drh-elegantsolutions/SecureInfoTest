package uk.gov.dwp.carersallowance.sensitiveinfo.git;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.lang3.StringUtils;

/**
 * GLOBAL excludes:  global defaults
 *
 * PROJECT excludes: $GIT_ROOT/info/exclude
 *
 * DIR excludes: git root adds one stack frame, clone the global one
 * and layer over it.  each directory, look for another .gitignore (where values are relative to the gitignore)
 * and possibly another .git and clone and layer on top of that as well,
 * so that as we unwind we get the original stack frame back.
 *
 *
 * the stack frames are going to need to incude the baseDir as well as the exludes (for global and project the baseDir is always GIT_ROOT)
 * for gitignore files, the baseDir is the location of the .gitignore
 *
 *
 *
 * ==============================================================================
 * Filter files to include only those that will be submitted to git.
 *
 * To work this out parse the .gitignore file(s).
 *
 * Assume baseDir is the git root directory (the one with .git directory in it)
 * or that git root is an ancestor of the baseDir and that git root contains .gitignore
 * or if not then .gitignore does not exist.
 *
 *
 * See https://git-scm.com/docs/gitignore
 *
 * DESCRIPTION
 * ===========
 *
 * A gitignore file specifies intentionally untracked files that Git should ignore. Files already
 * tracked by Git are not affected; see the NOTES below for details.
 *
 * Each line in a gitignore file specifies a pattern. When deciding whether to ignore a path, Git
 * normally checks gitignore patterns from multiple sources, with the following order of precedence,
 * from highest to lowest (within one level of precedence, the last matching pattern decides the outcome):
 *
 * Patterns read from the command line for those commands that support them.
 *
 * Patterns read from a .gitignore file in the same directory as the path, or in any parent directory,
 * with patterns in the higher level files (up to the toplevel of the work tree) being overridden by
 * those in lower level files down to the directory containing the file. These patterns match relative
 * to the location of the .gitignore file. A project normally includes such .gitignore files in its
 * repository, containing patterns for files generated as part of the project build.
 *
 * Patterns read from $GIT_DIR/info/exclude.
 *
 * Patterns read from the file specified by the configuration variable core.excludesFile.
 *
 * Which file to place a pattern in depends on how the pattern is meant to be used.
 *
 * Patterns which should be version-controlled and distributed to other repositories via clone
 * (i.e., files that all developers will want to ignore) should go into a .gitignore file.
 *
 * (See also https://git-scm.com/docs/git-config#FILES)
 * Patterns which are specific to a particular repository but which do not need to be shared with
 * other related repositories (e.g., auxiliary files that live inside the repository but are specific
 * to one user’s workflow) should go into the $GIT_DIR/info/exclude file.
 *
 * Patterns which a user wants Git to ignore in all situations (e.g., backup or temporary files
 * generated by the user’s editor of choice) generally go into a file specified by core.excludesFile
 * in the user’s ~/.gitconfig. Its default value is $XDG_CONFIG_HOME/git/ignore. If $XDG_CONFIG_HOME
 * is either not set or empty, $HOME/.config/git/ignore is used instead.
 *
 * The underlying Git plumbing tools, such as git ls-files and git read-tree, read gitignore patterns
 * specified by command-line options, or from files specified by command-line options. Higher-level
 * Git tools, such as git status and git add, use patterns from the sources specified above.
 *
 *
 * PATTERN FORMAT
 *    A blank line matches no files, so it can serve as a separator for readability.
 *
 *    A line starting with # serves as a comment. Put a backslash ("\") in front of
 *    the first hash for patterns that begin with a hash.
 *
 *    Trailing spaces are ignored unless they are quoted with backslash ("\").
 *
 *    An optional prefix "!" which negates the pattern; any matching file excluded
 *    by a previous pattern will become included again. It is not possible to re-include
 *    a file if a parent directory of that file is excluded. Git doesn’t list excluded
 *    directories for performance reasons, so any patterns on contained files have no effect,
 *    no matter where they are defined. Put a backslash ("\") in front of the first "!" for
 *    patterns that begin with a literal "!", for example, "\!important!.txt".
 *
 *    If the pattern ends with a slash, it is removed for the purpose of the following
 *    description, but it would only find a match with a directory. In other words, foo/
 *    will match a directory foo and paths underneath it, but will not match a regular
 *    file or a symbolic link foo (this is consistent with the way how pathspec works in
 *    general in Git).
 *
 *    If the pattern does not contain a slash /, Git treats it as a shell glob pattern and
 *    checks for a match against the pathname relative to the location of the .gitignore file
 *    (relative to the toplevel of the work tree if not from a .gitignore file).
 *
 *    Otherwise, Git treats the pattern as a shell glob suitable for consumption by fnmatch(3)
 *    with the FNM_PATHNAME flag: wildcards in the pattern will not match a / in the pathname.
 *    For example, "Documentation/*.html" matches "Documentation/git.html" but not
 *    "Documentation/ppc/ppc.html" or "tools/perf/Documentation/perf.html".
 *
 *    A leading slash matches the beginning of the pathname. For example, "/*.c" matches
 *    "cat-file.c" but not "mozilla-sha1/sha1.c".
 *
 *    Two consecutive asterisks ("**") in patterns matched against full pathname may have
 *    special meaning:
 *
 *    A leading "**" followed by a slash means match in all directories. For example, "** /foo"
 *    matches file or directory "foo" anywhere, the same as pattern "foo". "** /foo/bar" matches
 *    file or directory "bar" anywhere that is directly under directory "foo".
 *
 *    A trailing "/**" matches everything inside. For example, "abc/**" matches all files inside
 *    directory "abc", relative to the location of the .gitignore file, with infinite depth.
 *
 *    A slash followed by two consecutive asterisks then a slash matches zero or more directories.
 *    For example, "a/** /b" matches "a/b", "a/x/b", "a/x/y/b" and so on.
 *
 *    Other consecutive asterisks are considered invalid.
 *
 *
 * @author David Hutchinson (drh@elegantsolutions.co.uk) on 21 Feb 2017.
 *
 * TODO this version does not support the !pattern rule above (which emits a warning)
 */
public class GitSubmitFileFilter implements FileFilter {

    private File                         gitRoot;
    private GitExcludeContext            globalExclude;
    private GitExcludeContext            projectExclude;
    private Map<File, GitExcludeContext> gitIgnoreFileCache;   // dir vs GitExcludeContext

    public GitSubmitFileFilter(File baseDir) throws IOException, ParseException {
        gitIgnoreFileCache = new HashMap<>();
        gitRoot = canonicalize(initGitRoot(baseDir));

        globalExclude = initGlobalExclude(gitRoot);
        projectExclude = initProjectExclude(gitRoot);
    }

    public File getGitRoot() {
        return gitRoot;
    }

    private File initGitRoot(File baseDir) {
        if(baseDir == null) {
            throw new IllegalArgumentException("baseDir cannot be null");
        }

        if(baseDir.exists() == false) {
            return null;
        }

        if(baseDir.isDirectory() == false) {
            throw new IllegalArgumentException("baseDir(" + baseDir.getAbsolutePath() + ") is not a directory");
        }

        return getGitDir(baseDir);
    }

    /**
     * Find the git root, i.e. the directory with the .git directory
     */
    private File getGitDir(File dir) {
        if(dir.exists() == false) {
            return null;
        }

        File gitDir = new File(dir, ".git");
        if(gitDir.exists()) {
            return dir;
        }

        return getGitDir(dir.getParentFile());
    }

    private File canonicalize(File file) throws IOException {
        if(file == null) {
            return null;
        }
        return file.getCanonicalFile();
    }

    private GitExcludeContext initGlobalExclude(File gitRoot) throws IOException, ParseException {
        if(gitRoot == null) {
            return null;
        }

        File excludeFile = getCoreExcludesFile();
        if(excludeFile != null) {
            GitExcludeContext globalExclude = new GitExcludeContext(excludeFile, gitRoot, gitRoot); // coreExcludeFile paths are all relative to gitRoot
            return globalExclude;
        }

        return null;
    }

    /**
     * $GIT_ROOT/info/exclude
     * @throws IOException
     */
    private GitExcludeContext initProjectExclude(File gitRoot) throws IOException {
        if(gitRoot == null) {
            return null;
        }

        File excludeFile = new File(gitRoot, ".git/info/exclude");
        if(excludeFile.exists()) {
            GitExcludeContext projectExclude = new GitExcludeContext(excludeFile, gitRoot, gitRoot); // project exclude paths are all relative to gitRoot
            return projectExclude;
        }

        return null;
    }

    /**
     * look for a .gitignore file in baseDir
     */
    private GitExcludeContext readGitIgnore(File baseDir, File gitRoot) throws IOException {
        if(gitRoot == null) {
            throw new IllegalArgumentException("gitRoot cannot be null");
        }

        File gitIgnoreFile = new File(baseDir, ".gitignore");
        if(gitIgnoreFile.exists()) {
            GitExcludeContext result = new GitExcludeContext(gitIgnoreFile, baseDir, gitRoot);
            return result;
        }

        return null;
    }

    /**
     * Build a list of all the ExcludeContexts in order from the most specific first to the most general last
     * starting with the current pathname, up the pathnames ancestors until gitRoot and then project exclude and
     * global exclude.
     * @throws IOException
     */
    private List<GitExcludeContext> buildFullExcludeContext(File pathname) throws IOException {
        if(pathname == null) {
            return null;
        }

        List<GitExcludeContext> results = new ArrayList<>();

        File currentDir;
        if(pathname.isDirectory()) {
            currentDir = canonicalize(pathname);
        } else {
            currentDir = canonicalize(pathname.getParentFile());
        }

        File previousDir = null;
        while(currentDir != null && currentDir.equals(previousDir) == false) {
            // since current is canonicalized, and parent is derived as a substring of current, then parent is automatically canonicalized
            if(gitIgnoreFileCache.containsKey(currentDir) == false) {
                GitExcludeContext excludeContext = readGitIgnore(currentDir, gitRoot);  // returns null if no .gitignore
                gitIgnoreFileCache.put(currentDir, excludeContext);
                addToList(results, excludeContext);
            } else {
                addToList(results, gitIgnoreFileCache.get(currentDir)); // this can be null (which means its been checked and does not exist)
            }

            if(currentDir.equals(gitRoot)) {
                break;
            }

            previousDir = currentDir;
            currentDir = currentDir.getParentFile();
        }
        addToList(results, projectExclude);
        addToList(results, globalExclude);

        return results;
    }

    private void addToList(List<GitExcludeContext> list, GitExcludeContext instance) {
        assert list != null;
        if(instance != null) {
            list.add(instance);
        }
    }

    private boolean matchesGitIgnore(File pathname) throws IOException {
        if(pathname == null) {
            return false;
        }

        // need a list of exclude files in execution order
        List<GitExcludeContext> excludeContexts = buildFullExcludeContext(pathname);
        for(GitExcludeContext excludeContext: excludeContexts) {
            if(excludeContext.matchesGitIgnore(pathname)) {
                return true;
            }
        }

        return false;
    }

    @Override
    public boolean accept(File pathname) {
        try {
            if(matchesGitIgnore(pathname)) {
                System.out.println("ignoring: " + pathname.getAbsolutePath());
                return false;
            }
            return true;

        } catch (IOException e) {
            System.err.println("Unable to get pathname (" + pathname + ") as a canonical path, so erring on the side of caution and returning true;");
            return true;
        }
    }

    public static void walkTree(File file, FileFilter fileFilter) {
        assert fileFilter != null;
        if(file == null) {
            return;
        }

        // this will handle a file as well as a directory
        if(fileFilter.accept(file) == false) {
            return;
        }

        if(file.isDirectory()) {
            File[] children = file.listFiles(fileFilter);
            if(children != null) {
                for(File child : children) {
                    walkTree(child, fileFilter);
                }
            }
        }

        System.out.println(file.getAbsolutePath());
    }

    /**
     * Get the core excludes file.
     *
     * Note: all these paths are relative to the relevant git root.
     *
     * Patterns which a user wants Git to ignore in all situations (e.g., backup or temporary
     * files generated by the user’s editor of choice) generally go into a file specified by
     * core.excludesFile in the user’s ~/.gitconfig. Its default value is $XDG_CONFIG_HOME/git/ignore.
     * If $XDG_CONFIG_HOME is either not set or empty, $HOME/.config/git/ignore is used instead.
     *
     * @return
     * @throws IOException
     * @throws ParseException
     */
    private File getCoreExcludesFile() throws IOException, ParseException {
        String homePath = System.getProperty("user.home");
        File home = new File(homePath);

        // if specified in ~/.gitconfig use this value (and return)
        File gitConfigFile = new File(home, ".gitconfig");
        if(gitConfigFile.exists() == true) {
            GitConfig gitConfig = new GitConfig(gitConfigFile);
            if(gitConfig.containsKey("core.excludesFile")) {
                String coreExcludesFilePath = gitConfig.get("core.excludesFile");   // not sure if this is relative or absolute!?
                File result = new File(coreExcludesFilePath);
                return result;
            }
        }

        // if XDG_CONFIG_HOME is defined use it to locate /git/ignore (and return)
        String XDG_CONFIG_HOME = System.getenv("XDG_CONFIG_HOME");
        if(StringUtils.isEmpty(XDG_CONFIG_HOME) == false) {
            String path = XDG_CONFIG_HOME + "/git/ignore";
            File result = new File(path);
            return result;
        }

        // otherwiuse use ~/.config/git/ignore
        File homeGitIgnore = new File(home, ".config/git/ignore");
        return homeGitIgnore;
    }

    public static void main(String[] args) throws IOException, ParseException {
        String dirPath = "/Users/drh/release/SecureInfoTest";
        File dir = new File(dirPath);

        GitSubmitFileFilter fileFilter = new GitSubmitFileFilter(dir);
        System.out.println("Git Root = " + fileFilter.getGitRoot());

        walkTree(dir, fileFilter);
    }
}